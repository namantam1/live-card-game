# User Identity System Architecture

## Overview

The application uses **two separate identity systems** for different purposes. This document explains why, when to use each, and the trade-offs involved.

---

## The Two Identity Systems

### 1. **userId** - Persistent User Identity

**Purpose:** Track the same person across sessions, devices, and reconnections

**Characteristics:**

- Generated once per device/browser via UUID v4
- Stored in localStorage (`callbreak_user`)
- Never changes unless user clears browser data
- Unique per physical person/device

**Used In:**

- `PresenceRoom` - Online users list
- `UserIdentityManager` - Client-side identity management
- Future features: stats, friends, preferences, leaderboards

**Example:**

```
User "John" opens app:
  - First visit: Generate userId = "abc-123-def-456"
  - Saved to localStorage

Same user, multiple tabs:
  - Tab 1: userId = "abc-123-def-456"
  - Tab 2: userId = "abc-123-def-456" (SAME)

Next day:
  - userId = "abc-123-def-456" (SAME)
```

---

### 2. **sessionId** - Connection Identity

**Purpose:** Track individual connections/sessions for real-time game state

**Characteristics:**

- Generated by Colyseus server per connection
- Changes on every new connection (but preserved during reconnection)
- Unique per browser tab/connection
- Managed automatically by Colyseus

**Used In:**

- `CallBreakRoom` - Game state management
- Turn management (`currentTurn` field)
- Player state (hands, bids, tricks)
- All game logic and mechanics

**Example:**

```
User "John" plays game:
  - Tab 1: sessionId = "session-AAA" (Seat 0)
  - Connection drops â†’ reconnects â†’ sessionId = "session-AAA" (PRESERVED)

User opens second tab:
  - Tab 2: sessionId = "session-BBB" (Would be Seat 1)
```

---

## Why Two Systems?

### Presence vs. Game State

| Concern           | Presence Room     | Game Room                  |
| ----------------- | ----------------- | -------------------------- |
| **Goal**          | Show who's online | Manage active game         |
| **Identity**      | Person-centric    | Connection-centric         |
| **Multiple tabs** | Show once         | Each tab = separate player |
| **Reconnection**  | Same person       | Same game seat             |
| **Use case**      | "John is online"  | "Seat 0 plays card"        |

---

## Current Implementation

### PresenceRoom (uses userId)

```typescript
// Client connects with userId
client.joinOrCreate('presence', {
  userId: 'abc-123-def-456',
  name: 'John'
});

// Server stores by userId
onJoin(client, options) {
  client.auth = { userId: options.userId };

  // Prevent duplicates - same userId only appears once
  if (this.state.users.has(userId)) {
    // Update existing entry, don't create duplicate
  }
}

// Result: John appears ONCE in online users, even with 2 tabs
```

### CallBreakRoom (uses sessionId)

```typescript
// Client connects
client.join('call_break', {
  userId: 'abc-123-def-456',  // Received but NOT used currently
  name: 'John',
  roomCode: 'ABCD'
});

// Server uses sessionId for game state
onJoin(client, options) {
  player.id = client.sessionId;  // Uses sessionId!
  this.state.players.set(client.sessionId, player);
}

// Game logic uses sessionId
handlePlayCard(client, data) {
  if (this.state.currentTurn !== client.sessionId) return;
  // ...
}
```

---

## Identified Issues & Trade-offs

### âŒ Issue 1: Multiple Seats Per User (UNFIXED)

**Problem:**
Same person can open 2 tabs and occupy 2 seats in the same game (potential cheating).

**Current Behavior:**

```
John opens Tab 1:
  - sessionId: "AAA"
  - Joins game â†’ Gets Seat 0

John opens Tab 2:
  - sessionId: "BBB" (different!)
  - Joins game â†’ Gets Seat 1

Result: John controls 2 seats âŒ
```

**Why This Happens:**

- Game room uses `sessionId` for player identity
- Different tabs = different sessionIds
- No check to prevent same userId from joining twice

**Potential Solutions:**

**Option A: Block Multiple Seats (Stricter)**

```typescript
handleJoin(client, options) {
  const userId = options.userId;

  // Check if userId already in game
  const existingPlayer = Array.from(this.state.players.values())
    .find(p => p.userId === userId);

  if (existingPlayer) {
    throw new Error('Already in this game from another tab');
  }

  // Store both IDs
  player.id = client.sessionId;      // For game mechanics
  player.userId = options.userId;    // For duplicate prevention
}
```

**Option B: Allow Multi-Tab (Current - Permissive)**

```typescript
// Keep current behavior
// Rationale: Local testing, flexibility, rare in production
```

**Recommendation:** Implement Option A to prevent cheating.

---

### âœ… Design Decision: Why sessionId in Game Logic

**Question:** Why not use userId for turn management?

**Answer:** Colyseus architecture and reconnection handling

```typescript
// âŒ Using userId for turns (PROBLEMATIC)
currentTurn = "abc-123-def-456"  // userId

Problem:
- User has Tab 1 and Tab 2 both open
- currentTurn points to userId
- Which tab should be able to play? ðŸ¤”
- Colyseus sends messages to sessionId, not userId
- Reconnection uses sessionId preservation

// âœ… Using sessionId for turns (CORRECT)
currentTurn = "session-AAA"  // sessionId

Solution:
- Each seat = one connection = one sessionId
- Turn management is crystal clear
- Colyseus reconnection preserves sessionId
- Client.send() uses sessionId naturally
```

**Key Insight:**
Game state must track **connections**, not **people**. In a 4-player game, you need 4 separate connections, each with their own sessionId.

---

## Reconnection Flow

### How Colyseus Handles Reconnection

```typescript
// Connection drops
onLeave(client, code) {
  if (code !== CloseCode.CONSENTED) {
    // Allow same sessionId to reconnect
    await this.allowReconnection(client, 60);
  }
}

// Client reconnects within 60 seconds
// Colyseus magic: SAME sessionId is restored!
reconnectedClient.sessionId === originalClient.sessionId  // true âœ…

// Game state still works
this.state.players.get(reconnectedClient.sessionId)  // Found! âœ…
```

**Why This Matters:**

- `player.id = sessionId` works perfectly for reconnection
- No need to update game state or currentTurn
- Everything "just works" because sessionId is preserved

---

## Data Flow Diagrams

### Presence Room (userId-based)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Browser   â”‚
â”‚ localStorageâ”‚
â”‚ userId: ABC â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ connect(userId: "ABC", name: "John")
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   PresenceRoom Server   â”‚
â”‚                         â”‚
â”‚  client.auth.userId =   â”‚
â”‚    "ABC"                â”‚
â”‚                         â”‚
â”‚  state.users {          â”‚
â”‚    "ABC": {             â”‚
â”‚      id: "ABC",         â”‚
â”‚      name: "John",      â”‚
â”‚      inGame: false      â”‚
â”‚    }                    â”‚
â”‚  }                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Result: One entry per person
```

### Game Room (sessionId-based)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Browser    â”‚
â”‚  Tab 1      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ connect(userId:"ABC", name:"John")
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CallBreakRoom Server  â”‚
â”‚                         â”‚
â”‚  client.sessionId =     â”‚
â”‚    "session-AAA"        â”‚
â”‚                         â”‚
â”‚  state.players {        â”‚
â”‚    "session-AAA": {     â”‚
â”‚      id: "session-AAA", â”‚
â”‚      name: "John",      â”‚
â”‚      seatIndex: 0,      â”‚
â”‚      hand: [cards...]   â”‚
â”‚    }                    â”‚
â”‚  }                      â”‚
â”‚                         â”‚
â”‚  currentTurn:           â”‚
â”‚    "session-AAA"        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Result: One entry per connection/seat
```

---

## Best Practices

### âœ… DO

1. **Use userId for user-centric features**
   - Online presence
   - Friend lists
   - Stats tracking
   - Preferences

2. **Use sessionId for connection-centric features**
   - Game state management
   - Turn tracking
   - Real-time interactions

3. **Store both when needed**

   ```typescript
   class Player {
     id: string; // sessionId (primary key for game)
     userId?: string; // userId (for duplicate detection)
   }
   ```

4. **Validate userId uniqueness** when preventing multi-join

### âŒ DON'T

1. **Don't use userId for turn management** - Breaks with multiple tabs

2. **Don't use sessionId in localStorage** - Changes every connection

3. **Don't confuse the two** - Document clearly which ID is used where

---

## Implementation Checklist

### Current Status

- [x] UserIdentityManager generates and stores userId
- [x] PresenceRoom uses userId (prevents duplicates in online list)
- [x] CallBreakRoom receives userId (but doesn't store it)
- [x] Game logic uses sessionId for turns
- [ ] **TODO:** Prevent same userId from occupying multiple game seats
- [ ] **TODO:** Store userId in Player schema for future features

### To Fix Multi-Seat Issue

```typescript
// 1. Update Player schema
export class Player extends Schema {
  @type('string') id: string = '';        // sessionId
  @type('string') userId: string = '';    // Add userId field
  // ... rest
}

// 2. Check on join
handleJoin(client, options) {
  // Prevent duplicate userId in same game
  const exists = Array.from(this.room.state.players.values())
    .some(p => p.userId === options.userId);

  if (exists) {
    throw new Error('You are already in this game');
  }

  player.id = client.sessionId;
  player.userId = options.userId;  // Store both!
  // ...
}
```

---

## Summary

| Aspect           | userId          | sessionId             |
| ---------------- | --------------- | --------------------- |
| **Lifetime**     | Permanent       | Per-connection        |
| **Scope**        | Per person      | Per browser tab       |
| **Storage**      | localStorage    | Server memory         |
| **Purpose**      | Identify person | Identify connection   |
| **Managed by**   | Client          | Colyseus              |
| **Used for**     | User features   | Game mechanics        |
| **Reconnection** | Unchanged       | Preserved by Colyseus |

**Golden Rule:**

- Need to track **people**? Use `userId`
- Need to track **connections**? Use `sessionId`

---

## Future Considerations

### Potential Features Using userId

1. **Player Stats**

   ```typescript
   // Track across all games
   userStats[userId] = {
     gamesPlayed: 50,
     winRate: 0.65,
     avgScore: 234,
   };
   ```

2. **Friend System**

   ```typescript
   // Friend requests use userId
   friends[userId] = ['friend-id-1', 'friend-id-2'];
   ```

3. **Reconnect to Previous Room**
   ```typescript
   // Find active game for this userId
   const myGame = rooms.find((r) =>
     r.players.some((p) => p.userId === myUserId)
   );
   ```

Each feature should carefully consider which ID system to use based on whether it's person-centric or connection-centric.
